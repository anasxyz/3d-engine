/*
 Lab2start.cpp
 Creates a cube and defines a uniform variable to pass a transformation
 to the vertx shader.
 Use this example as a start to lab2 or extract bits and add to
 an example of your own to practice working with 3D transformations
 and uniform variables.
 Iain Martin October 2022
*/

/* Link to static libraries, could define these as linker inputs in the project
settings instead if you prefer */
#ifdef _DEBUG
#pragma comment(lib, "glfw3D.lib")
#else
#pragma comment(lib, "glfw3.lib")
#endif
#pragma comment(lib, "opengl32.lib")

/* Include the header to the GLFW wrapper class which
   also includes the OpenGL extension initialisation*/
#include "../include/GLFW/wrapper_glfw.h"
#include <iostream>

/* GLM headers */
#include "glm/gtc/matrix_transform.hpp"
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>

GLFWwindow *g_window = nullptr; // global window pointer

GLuint positionBufferObject, colourObject;
GLuint program;
GLuint vao;

/* position and view globals */
GLfloat angle_x, angle_x_inc;
GLfloat angle_y, angle_y_inc;
GLfloat angle_z, angle_z_inc;

/* global uniforms */
GLuint modelID;
GLuint viewID;
GLuint projectionID;

using namespace std;
using namespace glm;

// cube global variables
vec3 cubePosition(0.0f, 0.0f, -1.0f);
vec3 cubeScale(1.0f, 1.0f, 1.0f);

// camera variables
vec3 cameraPosition(0.0f, 0.0f, 2.0f);
vec3 cameraFront(0.0f, 0.0f, -1.0f);
vec3 cameraUp(0.0f, 1.0f, 0.0f);
float camYaw = -90.0f; // start facing toward -Z
float camPitch = 0.0f;

// window global variables
int width_g = 1024, height_g = 768;
float aspect;

/*
This function is called before entering the main rendering loop.
Use it for all your initialisation stuff
*/
void init(GLWrapper *glw) {
  angle_x = 0;
  angle_x_inc = 0;
  angle_y = 0;
  angle_y_inc = 0;
  angle_z = 0;
  angle_z_inc = 0;

  // Generate index (name) for one vertex array object
  glGenVertexArrays(1, &vao);

  // Create the vertex array object and make it current
  glBindVertexArray(vao);

  /* Define vertices for a cube in 12 triangles */
  GLfloat vertexPositions[] = {-0.25f, 0.25f,  -0.25f, 1.f,    -0.25f, -0.25f,
                               -0.25f, 1.f,    0.25f,  -0.25f, -0.25f, 1.f,

                               0.25f,  -0.25f, -0.25f, 1.f,    0.25f,  0.25f,
                               -0.25f, 1.f,    -0.25f, 0.25f,  -0.25f, 1.f,

                               0.25f,  -0.25f, -0.25f, 1.f,    0.25f,  -0.25f,
                               0.25f,  1.f,    0.25f,  0.25f,  -0.25f, 1.f,

                               0.25f,  -0.25f, 0.25f,  1.f,    0.25f,  0.25f,
                               0.25f,  1.f,    0.25f,  0.25f,  -0.25f, 1.f,

                               0.25f,  -0.25f, 0.25f,  1.f,    -0.25f, -0.25f,
                               0.25f,  1.f,    0.25f,  0.25f,  0.25f,  1.f,

                               -0.25f, -0.25f, 0.25f,  1.f,    -0.25f, 0.25f,
                               0.25f,  1.f,    0.25f,  0.25f,  0.25f,  1.f,

                               -0.25f, -0.25f, 0.25f,  1.f,    -0.25f, -0.25f,
                               -0.25f, 1.f,    -0.25f, 0.25f,  0.25f,  1.f,

                               -0.25f, -0.25f, -0.25f, 1.f,    -0.25f, 0.25f,
                               -0.25f, 1.f,    -0.25f, 0.25f,  0.25f,  1.f,

                               -0.25f, -0.25f, 0.25f,  1.f,    0.25f,  -0.25f,
                               0.25f,  1.f,    0.25f,  -0.25f, -0.25f, 1.f,

                               0.25f,  -0.25f, -0.25f, 1.f,    -0.25f, -0.25f,
                               -0.25f, 1.f,    -0.25f, -0.25f, 0.25f,  1.f,

                               -0.25f, 0.25f,  -0.25f, 1.f,    0.25f,  0.25f,
                               -0.25f, 1.f,    0.25f,  0.25f,  0.25f,  1.f,

                               0.25f,  0.25f,  0.25f,  1.f,    -0.25f, 0.25f,
                               0.25f,  1.f,    -0.25f, 0.25f,  -0.25f, 1.f};

  /* Define an array of colours */
  float vertexColours[] = {
      0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
      0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,

      0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f,
      0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f,

      1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f,
      1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f,

      1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
      1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,

      1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f,
      1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f,

      0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f,
      0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f,
  };

  glEnable(GL_DEPTH_TEST);

  /* Create a vertex buffer object to store vertices */
  glGenBuffers(1, &positionBufferObject);
  glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
  glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions,
               GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  /* Create a vertex buffer object to store vertex colours */
  glGenBuffers(1, &colourObject);
  glBindBuffer(GL_ARRAY_BUFFER, colourObject);
  glBufferData(GL_ARRAY_BUFFER, sizeof(vertexColours), vertexColours,
               GL_STATIC_DRAW);
  glBindBuffer(GL_ARRAY_BUFFER, 0);

  try {
    program = glw->LoadShader("shaders/lab2.vert", "shaders/lab2.frag");
  } catch (exception &e) {
    cout << "Caught exception: " << e.what() << endl;
    cin.ignore();
    exit(0);
  }

  /* Define uniforms to send to vertex shader */
  modelID = glGetUniformLocation(program, "model");
  viewID = glGetUniformLocation(program, "view");
  projectionID = glGetUniformLocation(program, "projection");
}

void updatePosition() {
  float moveSpeed = 0.01f;
  if (glfwGetKey(g_window, GLFW_KEY_UP) == GLFW_PRESS)
    cubePosition.y += moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_DOWN) == GLFW_PRESS)
    cubePosition.y -= moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_LEFT) == GLFW_PRESS)
    cubePosition.x -= moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    cubePosition.x += moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_PAGE_UP) == GLFW_PRESS)
    cubePosition.z += moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_PAGE_DOWN) == GLFW_PRESS)
    cubePosition.z -= moveSpeed;
}

void updateScale() {
  float scaleSpeed = 0.01f;
  if (glfwGetKey(g_window, GLFW_KEY_J) == GLFW_PRESS)
    cubeScale += glm::vec3(scaleSpeed);
  if (glfwGetKey(g_window, GLFW_KEY_K) == GLFW_PRESS)
    cubeScale -= glm::vec3(scaleSpeed);
}

void updateRotation() {
  float rotSpeed = 0.01f;
  if (glfwGetKey(g_window, GLFW_KEY_Y) == GLFW_PRESS)
    angle_x_inc += rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_U) == GLFW_PRESS)
    angle_x_inc -= rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_H) == GLFW_PRESS)
    angle_y_inc += rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_J) == GLFW_PRESS)
    angle_y_inc -= rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_N) == GLFW_PRESS)
    angle_z_inc += rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_M) == GLFW_PRESS)
    angle_z_inc -= rotSpeed;
}

void updateCamera() {
  float moveSpeed = 0.02f;
  float rotSpeed = 1.0f;

  // rotation (arrow keys)
  if (glfwGetKey(g_window, GLFW_KEY_LEFT) == GLFW_PRESS)
    camYaw -= rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    camYaw += rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_UP) == GLFW_PRESS)
    camPitch += rotSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_DOWN) == GLFW_PRESS)
    camPitch -= rotSpeed;

  // clamp pitch to avoid flipping
  if (camPitch > 89.0f)
    camPitch = 89.0f;
  if (camPitch < -89.0f)
    camPitch = -89.0f;

  // update cameraFront from yaw and pitch
  vec3 front;
  front.x = cos(radians(camYaw)) * cos(radians(camPitch));
  front.y = sin(radians(camPitch));
  front.z = sin(radians(camYaw)) * cos(radians(camPitch));
  cameraFront = normalize(front);

  // movement (wasd)
  if (glfwGetKey(g_window, GLFW_KEY_W) == GLFW_PRESS)
    cameraPosition += moveSpeed * cameraFront;
  if (glfwGetKey(g_window, GLFW_KEY_S) == GLFW_PRESS)
    cameraPosition -= moveSpeed * cameraFront;
  if (glfwGetKey(g_window, GLFW_KEY_A) == GLFW_PRESS)
    cameraPosition -= normalize(cross(cameraFront, cameraUp)) * moveSpeed;
  if (glfwGetKey(g_window, GLFW_KEY_D) == GLFW_PRESS)
    cameraPosition += normalize(cross(cameraFront, cameraUp)) * moveSpeed;
}

// Called to update the display.
// You should call glfwSwapBuffers() after all of your rendering to display what
// you rendered.
void display() {
	// std::cout << "Viewport: " << width_g << "x" << height_g << " aspect=" << aspect << std::endl;

  /* Define the background colour */
  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
  /* Clear the colour and frame buffers */
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glfwGetFramebufferSize(g_window, &width_g, &height_g);
  aspect = (float)width_g / (float)height_g;
	glViewport(0, 0, width_g, height_g);

  glUseProgram(program);

  glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, 0);

  glBindBuffer(GL_ARRAY_BUFFER, colourObject);
  glEnableVertexAttribArray(1);
  glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 0, 0);

  // updatePosition();
  // updateScale();
  // updateRotation();
  updateCamera();

  // model matrix: an identity matrix (model will be at the origin)
  mat4 model = mat4(1.0f);

  // translation:
  // model = translate(model, cubePosition);
  // translate in world space (independent of rotation / axis)
  model = translate(model, cubePosition);

  // rotation:
  // rotating in clockwise direction around x-axis
  model = rotate(model, -angle_x, vec3(1, 0, 0));
  // rotating in clockwise direction around y-axis
  model = rotate(model, -angle_y, vec3(0, 1, 0));
  // rotating in clockwise direction around z-axis
  model = rotate(model, -angle_z, vec3(0, 0, 1));

  // scale:
  model = scale(model, cubeScale);

  // create the view matrix
  mat4 view =
      glm::lookAt(cameraPosition, cameraPosition + cameraFront, cameraUp);

  mat4 projection = glm::perspective(glm::radians(45.0f), aspect, 0.1f, 100.0f);

  glUniformMatrix4fv(modelID, 1, GL_FALSE, &model[0][0]);
  glUniformMatrix4fv(viewID, 1, GL_FALSE, &view[0][0]);
  glUniformMatrix4fv(projectionID, 1, GL_FALSE, &projection[0][0]);

  glDrawArrays(GL_TRIANGLES, 0, 36);

  glDisableVertexAttribArray(0);
  glDisableVertexAttribArray(1);

  glUseProgram(0);

  /* Modify our animation variables */
  angle_x += angle_x_inc;
  angle_y += angle_y_inc;
  angle_z += angle_z_inc;
}

/* Called whenever the window is resized. The new window size is given, in
 * pixels. */
static void reshape(GLFWwindow *window, int w, int h) {
  glfwGetFramebufferSize(window, &width_g, &height_g);
  glViewport(0, 0, width_g, height_g);
}

/* change view angle, exit upon ESC */
static void keyCallback(GLFWwindow *window, int k, int s, int action,
                        int mods) {
  if (action != GLFW_PRESS)
    return;

  if (k == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
    glfwSetWindowShouldClose(window, GL_TRUE);
}

/* An error callback function to output GLFW errors*/
static void error_callback(int error, const char *description) {
  fputs(description, stderr);
}

/* Entry point of program */
int main(int argc, char *argv[]) {
  GLWrapper *glw = new GLWrapper(width_g, height_g, "Project");
  g_window = glw->getWindow();

  // glad: load all OpenGL function pointers
  // ---------------------------------------
  if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
    cout << "Failed to initialize GLAD. Exiting." << endl;
    return -1;
  }

  /* Note it you might want to move this call to the wrapper class */
  glw->setErrorCallback(error_callback);

  glw->setRenderer(display);
  glw->setKeyCallback(keyCallback);
  glw->setReshapeCallback(reshape);

  // Output version
  glw->DisplayVersion();

  init(glw);

  glw->eventLoop();

  delete (glw);
  return 0;
}
